// Copyright Â©2017 The go-hep Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lhef_test

import (
	"fmt"
	"os"
	"testing"

	"go-hep.org/x/hep/lhef"
)

const w_debug = false

func TestLhefWriting(t *testing.T) {
	f, err := os.CreateTemp("", "lhef-write-")
	if err != nil {
		t.Error(err)
	}
	defer func() {
		f.Close()
		os.Remove(f.Name())
	}()

	enc, err := lhef.NewEncoder(f)
	if err != nil {
		t.Error(err)
	}
	defer enc.Close()

	enc.Run = lhef.HEPRUP{
		IDBMUP: [2]int64{2212, -2212},
		EBMUP:  [2]float64{9.800000e+02, 9.800000e+02},
		PDFGUP: [2]int32{0, 0},
		PDFSUP: [2]int32{7, 7},
		IDWTUP: 3,
		NPRUP:  2,
		XSECUP: []float64{5.220106e+00, 2.602564e-01},
		XERRUP: []float64{5.384128e-01, 1.062492e-01},
		XMAXUP: []float64{1, 1},
		LPRUP:  []int32{81, 82},
	}

	evts := []lhef.HEPEUP{
		{
			NUP:    12,
			IDPRUP: 81,
			XWGTUP: 1.000000e+00,
			XPDWUP: [2]float64{0., 0.},
			SCALUP: 1.733125e+02,
			AQEDUP: 7.819848e-03,
			AQCDUP: 1.156692e-01,
			IDUP:   []int64{2, -2, 6, -6, 24, 5, -24, -5, -1, 2, 13, -14},
			ISTUP:  []int32{-1, -1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1},
			MOTHUP: [][2]int32{
				{0, 0}, {0, 0}, {1, 2}, {1, 2},
				{3, 0}, {3, 0}, {4, 0}, {4, 0},
				{5, 0}, {5, 0}, {7, 0}, {7, 0},
			},
			ICOLUP: [][2]int32{
				{101, 0}, {0, 102}, {101, 0}, {0, 102},
				{0, 0}, {101, 0}, {0, 0}, {0, 102},
				{0, 103}, {103, 0}, {0, 0}, {0, 0},
			},
			PUP: [][5]float64{
				{0.0000000000e+00, 0.0000000000e+00, 1.0838163607e+02, 1.0838163607e+02, 0.0000000000e+00},
				{0.0000000000e+00, 0.0000000000e+00, -2.7976111253e+02, 2.7976111253e+02, 0.0000000000e+00},
				{3.3629095553e+01, 8.9115695965e+00, -1.1059648961e+02, 2.1241781824e+02, 1.7798711709e+02},
				{-3.3629095553e+01, -8.9115695965e+00, -6.0782986840e+01, 1.7572493036e+02, 1.6116559038e+02},
				{-3.0884654830e+01, -1.2140252163e+01, -4.7852784957e+00, 8.6623320800e+01, 7.9871479200e+01},
				{6.4513750383e+01, 2.1051821759e+01, -1.0581121112e+02, 1.2579449744e+02, 4.8000000000e+00},
				{-5.0940382043e+01, 3.4880802250e+01, -7.5291578188e+01, 1.2621743906e+02, 8.0314552164e+01},
				{1.7311286490e+01, -4.3792371846e+01, 1.4508591348e+01, 4.9507491299e+01, 4.8000000000e+00},
				{1.8584463332e+01, 9.1657242037e+00, 1.8652036768e+01, 2.7881896512e+01, 3.3000000000e-01},
				{-4.9469118162e+01, -2.1305976366e+01, -2.3437315264e+01, 5.8741424288e+01, 3.3000000000e-01},
				{9.6912588119e+00, 3.9074488577e+01, -2.5560060185e+01, 4.7687147069e+01, 1.0566000000e-01},
				{-6.0631640855e+01, -4.1936863270e+00, -4.9731518002e+01, 7.8530291993e+01, 0.0000000000e+00},
			},
			VTIMUP: []float64{0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.},
			SPINUP: []float64{9., 9., 9., 9., 9., 9., 9., 9., 9., 9., 9., 9.},
		},
		{
			NUP:    12,
			IDPRUP: 81,
			XWGTUP: 1.000000e+00,
			XPDWUP: [2]float64{0., 0.},
			SCALUP: 2.453729e+02,
			AQEDUP: 7.850576e-03,
			AQCDUP: 1.102586e-01,
			IDUP:   []int64{2, -2, 6, -6, 24, 5, -24, -5, -3, 4, 15, -16},
			ISTUP:  []int32{-1, -1, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1},
			MOTHUP: [][2]int32{
				{0, 0}, {0, 0}, {1, 2}, {1, 2},
				{3, 0}, {3, 0}, {4, 0}, {4, 0},
				{5, 0}, {5, 0}, {7, 0}, {7, 0},
			},
			ICOLUP: [][2]int32{
				{101, 0}, {0, 102}, {101, 0}, {0, 102},
				{0, 0}, {101, 0}, {0, 0}, {0, 102},
				{0, 103}, {103, 0}, {0, 0}, {0, 0},
			},
			PUP: [][5]float64{
				{0.0000000000e+00, 0.0000000000e+00, 1.4168500180e+02, 1.4168500180e+02, 0.0000000000e+00},
				{0.0000000000e+00, 0.0000000000e+00, -5.1193431229e+02, 5.1193431229e+02, 0.0000000000e+00},
				{1.4483021237e+02, -9.1836222700e+01, -3.2020944169e+02, 4.0376632938e+02, 1.7630507646e+02},
				{-1.4483021237e+02, 9.1836222700e+01, -5.0039868808e+01, 2.4985298471e+02, 1.7467925831e+02},
				{6.6573250937e+01, -1.0557760324e+02, -2.7628620725e+02, 3.1285280962e+02, 7.7228130408e+01},
				{7.8256961429e+01, 1.3741380542e+01, -4.3923234434e+01, 9.0913519757e+01, 4.8000000000e+00},
				{-5.2331928485e+01, 1.3655957736e+01, 3.5832022017e+01, 1.0130969814e+02, 7.7811343743e+01},
				{-9.2498283882e+01, 7.8180264964e+01, -8.5871890826e+01, 1.4854328657e+02, 4.8000000000e+00},
				{1.3698476364e+01, -8.8968981168e+01, -1.5010039084e+02, 1.7502429887e+02, 5.0000000000e-01},
				{5.2874774574e+01, -1.6608622073e+01, -1.2618581641e+02, 1.3782851075e+02, 1.5000000000e+00},
				{-5.3810426731e+01, -1.6793177176e+00, -8.3584775043e+00, 5.4510586203e+01, 1.7770000000e+00},
				{1.4784982465e+00, 1.5335275454e+01, 4.4190499522e+01, 4.6799111939e+01, 0.0000000000e+00},
			},
			VTIMUP: []float64{0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.},
			SPINUP: []float64{9., 9., 9., 9., 9., 9., 9., 9., 9., 9., 9., 9.},
		},
	}
	for i, evt := range evts {
		err = enc.Encode(&evt)
		if err != nil {
			t.Error(err)
		}
		if w_debug {
			fmt.Printf("===[%d]===\nevt: %v\n", i, evt)
		}
	}

	if w_debug {
		defer func() {
			enc.Close()
			ww, _ := os.ReadFile(f.Name())
			fmt.Printf("===>\n%v<===\n", string(ww))
		}()
	}
}
